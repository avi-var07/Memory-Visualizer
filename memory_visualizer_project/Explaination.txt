"""
==================================================
ğŸ§  MEMORY MANAGEMENT SIMULATOR â€“ FUNCTIONALITY DOC
==================================================

This simulator demonstrates three core memory management techniques used in modern operating systems:
    1. Paging (Fixed-size memory allocation)
    2. Segmentation (Variable-size memory allocation)
    3. Virtual Memory (Demand paging and swapping)

Implemented using Python with Streamlit (for GUI) and Plotly (for visualization).
Each memory management technique is encapsulated in a dedicated class.

=================================================================================
1ï¸âƒ£ CLASS: MemorySimulator â€“ Paging with Page Replacement Algorithms
=================================================================================

ğŸ“Œ Purpose:
    Simulates memory divided into fixed-size pages.
    Allocates processes by splitting them into pages and placing them in available memory frames.

ğŸ“Œ Key Attributes:
    - self.memory: list storing process IDs per page slot.
    - self.page_faults, self.hits: counters for simulation metrics.
    - self.fifo_queue, self.lru_tracker, self.lfu_counter: structures for page replacement.
    - self.internal_fragmentation: memory lost within allocated pages.

ğŸ“Œ Key Methods:

ğŸ”¹ allocate_process(process_id, size, algorithm, time_step)
    - Calculates number of pages needed for a process.
    - Allocates into free memory if available.
    - If not enough space, performs page replacement based on the algorithm.

ğŸ”¹ _replace_page(algorithm, process_id, time_step)
    - FIFO: Replaces the page that was loaded earliest.
        â†’ old_page = self.fifo_queue.popleft()
    - LRU: Replaces the least recently accessed page.
        â†’ oldest = min(self.lru_tracker, key=self.lru_tracker.get)
    - LFU: Replaces the least frequently used page; uses LRU as tiebreaker on ties.
        â†’ least_freq = min(self.lfu_counter.values())

ğŸ”¹ deallocate_process(process_id)
    - Frees all pages occupied by the process and updates tracking structures.

ğŸ”¹ get_metrics()
    - Returns: page_faults, hit_ratio, internal_fragmentation

ğŸ”¹ plot_memory()
    - Returns a bar chart showing memory usage by pages and processes.

=================================================================================
2ï¸âƒ£ CLASS: SegmentationSimulator â€“ Variable-size Segment Allocation
=================================================================================

ğŸ“Œ Purpose:
    Simulates memory allocation by segments (code, data, stack, etc.).
    Allocates memory using dynamic-sized blocks instead of fixed-size pages.

ğŸ“Œ Key Attributes:
    - self.memory: memory as a list of addresses, each storing a tuple (process_id, segment_name).
    - self.segment_table: dictionary mapping process_id â†’ list of segments (name, start, size).
    - self.free_blocks: list of available blocks in memory.
    - self.segmentation_faults: tracks allocation failures.

ğŸ“Œ Allocation Strategies:

ğŸ”¹ First-Fit:
    - Selects the first block that is large enough.
    â†’ self._first_fit(size)

ğŸ”¹ Best-Fit:
    - Selects the smallest block that can fit the segment.
    â†’ self._best_fit(size)

ğŸ”¹ Worst-Fit:
    - Selects the largest block in memory.
    â†’ self._worst_fit(size)

ğŸ“Œ Key Methods:

ğŸ”¹ allocate_segment(process_id, segment_name, segment_size, algorithm)
    - Finds a block using the chosen strategy and allocates it.

ğŸ”¹ deallocate_segment(process_id, segment_name=None)
    - Removes a segment or all segments of a process and merges adjacent free blocks.

ğŸ”¹ analyze_fragmentation()
    - Returns metrics like used memory, free memory, external fragmentation, fragmentation index, etc.

ğŸ”¹ plot_fragmentation()
    - Visualizes memory usage (pie chart) and distribution of free blocks (bar chart).

ğŸ”¹ plot_memory()
    - Returns a stacked bar chart of memory segments and their owners.

=================================================================================
3ï¸âƒ£ CLASS: VirtualMemorySimulator â€“ Virtual Memory & Demand Paging
=================================================================================

ğŸ“Œ Purpose:
    Models a virtual memory system that supports:
        - Virtual to physical address translation
        - Demand paging
        - Swapping pages in/out from disk (swap space)

ğŸ“Œ Key Attributes:
    - self.physical_memory: list of physical frames
    - self.page_table: virtual_page â†’ physical_frame
    - self.reverse_mapping: physical_frame â†’ virtual_page
    - self.swap_space: disk-stored pages
    - self.page_faults, disk_reads, disk_writes: performance metrics
    - self.lru_tracker, lfu_counter, fifo_queue: for page replacement

ğŸ“Œ Key Methods:

ğŸ”¹ access_address(virtual_address, process_id, write=False, algorithm)
    - Translates a virtual address to physical.
    - If the page is not in memory (page fault), a replacement is triggered.
    - Updates relevant tracking structures.

ğŸ”¹ _replace_page(algorithm)
    - Chooses a physical frame to evict using:
        FIFO â†’ self.fifo_queue.popleft()
        LRU  â†’ min(self.lru_tracker.items(), key=lambda x: x[1])[0]
        LFU  â†’ least accessed page + LRU tie-breaker

ğŸ”¹ allocate_process(process_id, size)
    - Pre-allocates virtual pages for the process in the virtual address space.

ğŸ”¹ get_metrics()
    - Returns page_faults, disk_reads/writes, physical & swap utilization.

ğŸ”¹ plot_memory_maps()
    - Returns bar charts of physical and virtual memory layouts.

ğŸ“Œ Behavior:
    - If physical memory is full:
        â†’ A page is swapped out to disk (simulated swap space).
    - Swapped-in pages are counted as disk reads; evicted pages as disk writes.

=================================================================================
ğŸ“Œ COMMON VISUALIZATION TOOLS (across all simulators):
    - plot_memory()      â†’ Memory bar chart (paging/segmentation)
    - plot_fragmentation() â†’ Pie + bar chart for fragmentation
    - plot_memory_maps()  â†’ Physical & virtual memory state
=================================================================================

"""
